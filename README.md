# 🚗 SMARTGUARD ROVER (실내 경비 스마트카)

> **임베디드 & 지능로봇 개발자 과정 Team 4 프로젝트**
> 사람이 직접 순찰하기 힘든 실내 공간을 원격으로 제어하며, 화재 및 환경 변화를 실시간으로 감시하는 이동형 로봇입니다.

---

## 📖 프로젝트 목표 (Project Goal)

**SMARTGUARD ROVER**는 스마트폰을 통해 원격 제어가 가능하며, 위험 상황 발생 시 사용자의 제어권을 차단하고 안전 모드로 진입하여 사고를 예방하는 지능형 실내 경비 로봇입니다.

* **원격 제어 및 감시:** 사람이 접근하기 힘든 공간을 원격으로 이동하며 환경 감시
* **실시간 위험 감지:** 화재, 장애물, 전복 사고 등 위험 상황 실시간 감지
* **안전 모드 (Fail-safe):** 위험 감지 시 사용자 제어권 차단 및 비상 루틴 수행 (모터 정지 등)

---

## ⚙️ 시스템 구성 (System Architecture)

### 🛠 하드웨어 (Hardware)
STM32 MCU를 메인 컨트롤러로 사용하여 다양한 센서와 통신 모듈을 제어합니다.

* **MCU:** STM32
* **통신:**
    * Bluetooth (HC-06) ↔ 노트북(웹서버)
    * Wi-Fi ↔ 스마트폰 (대시보드 및 제어)
* **센서 (Sensors):**
    * **GPIO (디지털):** 불꽃 감지 센서, IR 장애물 감지 센서, 각도 스위치
    * **ADC (아날로그):** 조도 센서, 온습도 센서
    * **TIM (타이머):** 초음파 센서
* **구동부 (Actuators):** DC 모터 & 모터 드라이버, 부저, LED

### 💻 소프트웨어 로직 (Software Flow)
시스템은 **최우선 루틴(화재 발생)**을 기반으로 상황에 따라 동작 모드가 변경됩니다.

1.  **화재 감지 (Priority 1):** 불꽃 감지 센서 작동 시 **모든 모터 정지**
2.  **전복 감지:** 각도 센서가 기울임(180도 회전/3초 이상) 감지 시 부저 경보 울림
3.  **장애물 회피:**
    * 초음파 센서(전방) 감지 시 회피
    * IR 센서(좌/우) 감지 시 반대 방향으로 회전
4.  **자동 조명:** 조도 센서가 어두운 곳 진입 감지 시 LED 자동 점등
5.  **데이터 모니터링:** 온습도 센서 데이터 및 경보 상황을 스마트폰 앱으로 실시간 전송
6.  **사용자 주행 (IDLE):** 평시에는 스마트폰을 통해 전진/후진/좌회전/우회전 제어

---

## 🔧 개발 환경 (Tech Stack)

| Category | Components / Stack |
| :--- | :--- |
| **MCU** | STM32 |
| **Language** | C, C++ |
| **IDE** | STM32CubeIDE |
| **Wireless** | Bluetooth (HC-06), Wi-Fi |
| **App/Server** | Android (SmartPhone), Web Server (Laptop) |

---

## 👥 팀원 및 역할 분담 (Team & Roles)

**Team 4**

| 이름 | 담당 업무 (Role) | 상세 구현 내용 |
| :---: | :--- | :--- |
| **홍민국** | **센서 제어 및 화재 감지** | • 조도 센서 제어 (ADC)<br>• 온습도 센서 제어 (ADC)<br>• 화재 감지 알고리즘 구현<br>• 센서 통합 및 작동 테스트 |
| **장현준** | **주행 제어 및 충돌 방지** | • 충돌 방지 알고리즘 구현 (초음파/IR)<br>• 각도 센서 제어 (GPIO)<br>• 부저 센서 제어 (TIM)<br>• 센서 통합 및 작동 테스트 |

---

## 📅 프로젝트 일정 (Schedule)

* **Day 1 (1/26):** 조도 센서 제어 (완료) / 충돌 방지 알고리즘 구현 (완료)
* **Day 2 (1/27):** 화재 감지 알고리즘 / 각도 센서 제어
* **Day 3 (1/28):** 온습도 센서 제어 / 부저 센서 제어
* **Day 4 (1/29):** 전체 센서 통합 및 작동 테스트
* **Day 5 (1/30):** 통신 모듈(Bluetooth/Wi-Fi) 연동 및 최종 디버깅

---
# 🚦 장애물 회피 및 주행 알고리즘 (Obstacle Avoidance Logic)

> **개요:** 전방의 초음파 센서(2개)가 장애물을 감지하면, 측면 IR 센서(2개)를 통해 안전한 경로를 탐색하고 회피 기동을 수행하는 로직입니다.

---

## 1. 센서 구성 및 역할 (Sensor Configuration)

| 센서 타입 | 수량 | 역할 (Role) | 변수명 예시 |
| :--- | :---: | :--- | :--- |
| **초음파 센서**<br>(HC-SR04) | 2 | **전방 거리 감지**<br>- 전방 장애물까지의 거리(cm) 측정<br>- 두 센서 중 하나라도 임계값 이하일 경우 감지로 판단 | `dist1`, `dist2` |
| **초음파 센서**<br>(HC-SR04)) | 2 |**좌우 측면 장애물 유무 판단**<br>- 근거리(측면) 장애물 유무 확인 (Digital Input 0/1) |`dist3`, `dist4`|

---

## 2. 감지 로직 흐름도 (Logic Flow)

알고리즘은 **전방 감시(Monitoring)** 상태를 유지하다가 조건 충족 시 **회피 기동(Avoidance)** 으로 전환됩니다.

### 📌 Step 1: 전방 거리 측정 (Monitoring)
1.  듀얼 초음파 센서(`Ultrasonic 1`, `Ultrasonic 2`)를 통해 전방 거리를 지속적으로 측정합니다.
2.  **판단 기준:** 두 센서 중 **최소값**이 **15cm 이하**인가?
    * `min(dist1, dist2) <= 15cm`

### 📌 Step 2: 측면 공간 탐색 (Scanning)
전방 장애물이 감지된 순간(`True`), 차량을 **일시 정지(Stop)** 하고 좌우 초음파 센서 값을 읽습니다.

* **Left Check:** 좌측 장애물 유무 (`HIGH`: 장애물 없음 / `LOW`: 장애물 있음) *※ 센서 특성에 따라 다름*
* **Right Check:** 우측 장애물 유무

### 📌 Step 3: 주행 방향 결정 (Decision Making)
IR 센서 값의 조합에 따라 다음 행동을 결정합니다.

| Case | 전방 (Ultrasonic) | 좌측 (Left) | 우측 (Right) | **행동 (Action)** |
| :---: | :---: | :---: | :---: | :--- |
| **1** | **15cm 이내** | **장애물 없음** | **장애물 없음** | **우회전 (기본값) 또는 랜덤 회전** |
| **2** | **15cm 이내** | **장애물 없음** | 장애물 있음 | **좌회전 (Left Turn)** |
| **3** | **15cm 이내** | 장애물 있음 | **장애물 없음** | **우회전 (Right Turn)** |
| **4** | **15cm 이내** | 장애물 있음 | 장애물 있음 | **후진 후 180도 회전 (U-Turn)** |
| **5** | 15cm 초과 | (무시) | (무시) | **직진 (Go Straight)** |

---
## 3. 듀얼 초음파 센서 측정 테스트
<img width="634" height="529" alt="image" src="https://github.com/user-attachments/assets/042074c4-e1fe-4fb5-9f0c-cd87493d230f" />

## 문제상황 1
- 1번 초음파 센서의 TRIG1 핀을 PA8 핀에 할당하고 시간 측정을 위해 TIM1을 사용하였으나, 센서가 동작하지않고 거리 값이 측정되지 않는 현상이발생

# 원인
- IOC에서도 계속 warning이 뜨던 이유중 하나로 PA8 핀은 TIM1_CH1 고유핀으로 설정되어있음
- 따라서 코드상에서 PA8핀을 GPIO_OUTPUT으로 설정해도 핀의 제어권이 GPIO_OUTPUT이 아닌 TIM_INIT함수가 먼저실행되면서 작동이 되지않음
# 해결방안
- TIM1 비활성화
- TIM2로 초음파센서를 공유해서 사용
- 이때 타이머를 공유해도 되는 이유로는 초음파센서 2개를 순서대로 측정하는 방식을 사용하기 때문에
- TIM2 카운터 0으로 리셋 > 센서1 측정, TIM2 카운터0으로 리셋> 센서2 측정하는 방식이므로 가능하다.
- 순서대로 측정하면 갱신시간에 문제가있을거같지만, 실제로 2m거리를 초음파가 갔다 오는데 걸리는 시간은 0.011초고 센서1,대기,센서2 측정까지 걸리는 시간에는 0.024초가 소모되므로 사실상 사람이 반응하기에는 충분한 시간이다

## 문제상황 2
- 키 입력시 반응속도가 너무느린 문제가 생김

**🔍 원인 분석 (Root Cause): 폴링(Polling) 방식의 한계**
* **Blocking 구조:** 초기 코드에서는 `HAL_UART_Receive` 함수에 타임아웃을 설정하거나, 초음파 센서의 응답을 기다리는 `while` 루프(Echo 대기)가 실행되는 동안 **CPU가 해당 라인에 멈춰(Blocking) 있었음.**
* **동기식 처리의 문제:** 1.  CPU가 초음파 센서 값을 읽기 위해 대기하는 시간(수십 ms) 동안에는 UART 데이터 레지스터를 확인하지 못함.
    2.  이 순간에 들어온 키보드 입력 데이터가 오버런(Overrun)되거나 무시됨.
    3.  결과적으로 사용자는 "반응이 느리다"고 느끼게 됨.

**✅ 해결 방안 (Solution): 인터럽트(Interrupt) 방식 도입**
* **비동기(Asynchronous) 처리:** UART 수신 방식을 기존의 폴링 방식(`HAL_UART_Receive`)에서 **인터럽트 방식(`HAL_UART_Receive_IT`)**으로 변경.
* **콜백 함수 활용:** `HAL_UART_RxCpltCallback` 함수를 구현하여, 메인 루프가 초음파 센서를 측정하고 있더라도 **키 입력이 들어오는 즉시(Real-time)** 하던 일을 멈추고 모터 제어 명령을 우선 수행하도록 구조 개선.
* **결과:** 센서 측정 여부와 관계없이 키보드 입력에 대해 **즉각적인 반응 속도(Zero Latency)** 확보.

| 구분 | 변경 전 (Polling) | 변경 후 (Interrupt) |
| :--- | :--- | :--- |
| **동작 방식** | "데이터 왔니?" 하고 계속 물어봄 (대기 발생) | 하던 일 하다가 "데이터 오면 알려줘" (대기 없음) |
| **CPU 점유** | 데이터 대기 중 CPU 낭비 심함 | 효율적 (이벤트 발생 시에만 처리) |
| **반응 속도** | 느림 (루프 주기에 종속됨) | **매우 빠름 (즉시 반응)** |

** 주의해야할점 **
- 인터럽트 방식은 메인루프의 할일을 새치기해서 먼저 동작하는 방식이기때문에 실제로는 인터럽트가 작동한 그만큼의 시간은 메인 루프에서 뒤로 밀리게 된다
- 다만 현재 스마트카에서는 키보드 입력시간은 약 5us정도고 초음파측정주기는 약 25ms정도이므로 25.005ms로 늘어났기때문에 실제로는 빠르게 작동된다.
- 만약 다른 예제에서 어떤 센서가 마이크로초 단위로 아주 정밀하게 작동되고있다면 그 사이에 인터럽트가 끼어들면 오차가 생길수도있으니 주의해야한다
- 
## 문제상황3
- 현재 양쪽에 IR장애물감지센서를 달았는데, 센서 자체의 감도문제인지 장애물이 나타나면 잠깐 신호가 가고 꺼지게된다
- 따라서 현재 양옆의 장애물을 측정 하지못하는 상황

** 해결 방안 **
- ~~IR 장애물 센서의 감도를 조절~~
- ~~초음파 센서를 좌우에 단다~~
- ~~이럴경우 전방에 초음파센서 하나, 좌우에 초음파센서 두개를 달아 총 3개의 초음파센서를 사용해야할가능성~~

# ⚡ 임베디드 시스템 입력 처리 방식 비교: 폴링 vs 인터럽트

이 문서는 MCU(Micro Controller Unit)에서 센서나 버튼 등의 외부 입력을 처리하는 두 가지 핵심 방식인 **폴링(Polling)**과 **인터럽트(Interrupt)**의 개념, 장단점, 그리고 실제 적용 사례를 비교 정리한 것입니다.

---

## 1. 개념 및 비유

| 구분 | **폴링 (Polling)** | **인터럽트 (Interrupt)** |
| :--- | :--- | :--- |
| **핵심 개념** | **"주기적 검사"** | **"사건 발생 시 즉각 반응"** |
| **비유 (상황)** | 공부를 하다가 **5분에 한 번씩 현관문으로 나가** 택배가 왔는지 확인하고 돌아옴. | 공부에 집중하다가 **초인종이 "딩동" 울리면** 하던 공부를 멈추고 뛰쳐나감. |
| **주체** | **소프트웨어** (개발자가 시점 결정) | **하드웨어** (신호가 들어오면 강제 실행) |

---

## 2. 상세 비교표

| 비교 항목 | 폴링 (Polling) | 인터럽트 (Interrupt) |
| :--- | :--- | :--- |
| **구현 위치** | `main()` 함수의 `while(1)` 루프 내부 | `HAL_GPIO_EXTI_Callback` 등 별도 함수 |
| **반응 속도** | 루프가 한 바퀴 도는 시간에 의존 (느림) | 사건 발생 즉시 반응 (매우 빠름, Real-time) |
| **CPU 효율** | 변화가 없어도 계속 확인해야 하므로 **낭비**됨 | 사건이 없을 땐 CPU가 쉴 수 있어 **효율적** |
| **복잡도** | 흐름이 순차적이라 이해와 디버깅이 **쉬움** | 언제 호출될지 몰라 흐름 파악이 **어려움** |
| **노이즈 내성** | **강함** (순간적인 노이즈 무시 가능) | **약함** (노이즈에도 민감하게 반응하여 오작동) |
| **제약 사항** | 특별한 제약 없음 (Delay 사용 가능) | **Blocking 함수 사용 불가** (Delay, 긴 연산 금지) |

---

## 3. 코드 구조 예시

### ✅ 폴링 (Polling) 방식
`main` 루프의 흐름에 따라 순서대로 센서를 확인합니다.

```c
while (1)
{
    // 1. 다른 작업 수행
    Motor_Drive();

    // 2. 센서 확인 (직접 검사)
    if (HAL_GPIO_ReadPin(SENSOR_PORT, SENSOR_PIN) == GPIO_PIN_SET)
    {
        // 3. 조건 만족 시 처리 (무거운 작업 가능)
        LCD_Draw_Alert(); 
        HAL_Delay(100);
    }
}
