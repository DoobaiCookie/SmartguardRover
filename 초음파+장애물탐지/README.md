# 🚦 장애물 회피 및 주행 알고리즘 (Obstacle Avoidance Logic)

> **개요:** 전방의 초음파 센서(2개)가 장애물을 감지하면, 측면 IR 센서(2개)를 통해 안전한 경로를 탐색하고 회피 기동을 수행하는 로직입니다.

---

## 1. 센서 구성 및 역할 (Sensor Configuration)

| 센서 타입 | 수량 | 역할 (Role) | 변수명 예시 |
| :--- | :---: | :--- | :--- |
| **초음파 센서**<br>(HC-SR04) | 2 | **전방 거리 감지**<br>- 전방 장애물까지의 거리(cm) 측정<br>- 두 센서 중 하나라도 임계값 이하일 경우 감지로 판단 | `dist_L`, `dist_R` |
| ~~**적외선 센서**<br>(IR-08H)~~ 초음파센서로 대체 예정 | 2 |~~**좌우 측면 장애물 유무 판단**<br>- 근거리(측면) 장애물 유무 확인 (Digital Input 0/1)~~ |~~`ir_left`, `ir_right`~~|

---

## 2. 감지 로직 흐름도 (Logic Flow)

알고리즘은 **전방 감시(Monitoring)** 상태를 유지하다가 조건 충족 시 **회피 기동(Avoidance)** 으로 전환됩니다.

### 📌 Step 1: 전방 거리 측정 (Monitoring)
1.  듀얼 초음파 센서(`Ultrasonic 1`, `Ultrasonic 2`)를 통해 전방 거리를 지속적으로 측정합니다.
2.  **판단 기준:** 두 센서 중 **최소값**이 **15cm 이하**인가?
    * `min(dist1, dist2) <= 15cm`

### 📌 Step 2: 측면 공간 탐색 (Scanning)
전방 장애물이 감지된 순간(`True`), 차량을 **일시 정지(Stop)** 하고 좌우 IR 센서 값을 읽습니다.

* **Left IR Check:** 좌측 장애물 유무 (`HIGH`: 장애물 없음 / `LOW`: 장애물 있음) *※ 센서 특성에 따라 다름*
* **Right IR Check:** 우측 장애물 유무

### 📌 Step 3: 주행 방향 결정 (Decision Making)
IR 센서 값의 조합에 따라 다음 행동을 결정합니다.

| Case | 전방 (Ultrasonic) | 좌측 (IR Left) | 우측 (IR Right) | **행동 (Action)** |
| :---: | :---: | :---: | :---: | :--- |
| **1** | **15cm 이내** | **장애물 없음** | **장애물 없음** | **우회전 (기본값) 또는 랜덤 회전** |
| **2** | **15cm 이내** | **장애물 없음** | 장애물 있음 | **좌회전 (Left Turn)** |
| **3** | **15cm 이내** | 장애물 있음 | **장애물 없음** | **우회전 (Right Turn)** |
| **4** | **15cm 이내** | 장애물 있음 | 장애물 있음 | **후진 후 180도 회전 (U-Turn)** |
| **5** | 15cm 초과 | (무시) | (무시) | **직진 (Go Straight)** |

---
## 3. 듀얼 초음파 센서 측정 테스트
<img width="634" height="529" alt="image" src="https://github.com/user-attachments/assets/042074c4-e1fe-4fb5-9f0c-cd87493d230f" />

## 문제상황 1
- 1번 초음파 센서의 TRIG1 핀을 PA8 핀에 할당하고 시간 측정을 위해 TIM1을 사용하였으나, 센서가 동작하지않고 거리 값이 측정되지 않는 현상이발생

# 원인
- IOC에서도 계속 warning이 뜨던 이유중 하나로 PA8 핀은 TIM1_CH1 고유핀으로 설정되어있음
- 따라서 코드상에서 PA8핀을 GPIO_OUTPUT으로 설정해도 핀의 제어권이 GPIO_OUTPUT이 아닌 TIM_INIT함수가 먼저실행되면서 작동이 되지않음
# 해결방안
- TIM1 비활성화
- TIM2로 초음파센서를 공유해서 사용
- 이때 타이머를 공유해도 되는 이유로는 초음파센서 2개를 순서대로 측정하는 방식을 사용하기 때문에
- TIM2 카운터 0으로 리셋 > 센서1 측정, TIM2 카운터0으로 리셋> 센서2 측정하는 방식이므로 가능하다.
- 순서대로 측정하면 갱신시간에 문제가있을거같지만, 실제로 2m거리를 초음파가 갔다 오는데 걸리는 시간은 0.011초고 센서1,대기,센서2 측정까지 걸리는 시간에는 0.024초가 소모되므로 사실상 사람이 반응하기에는 충분한 시간이다

## 문제상황 2
- 키 입력시 반응속도가 너무느린 문제가 생김

**🔍 원인 분석 (Root Cause): 폴링(Polling) 방식의 한계**
* **Blocking 구조:** 초기 코드에서는 `HAL_UART_Receive` 함수에 타임아웃을 설정하거나, 초음파 센서의 응답을 기다리는 `while` 루프(Echo 대기)가 실행되는 동안 **CPU가 해당 라인에 멈춰(Blocking) 있었음.**
* **동기식 처리의 문제:** 1.  CPU가 초음파 센서 값을 읽기 위해 대기하는 시간(수십 ms) 동안에는 UART 데이터 레지스터를 확인하지 못함.
    2.  이 순간에 들어온 키보드 입력 데이터가 오버런(Overrun)되거나 무시됨.
    3.  결과적으로 사용자는 "반응이 느리다"고 느끼게 됨.

**✅ 해결 방안 (Solution): 인터럽트(Interrupt) 방식 도입**
* **비동기(Asynchronous) 처리:** UART 수신 방식을 기존의 폴링 방식(`HAL_UART_Receive`)에서 **인터럽트 방식(`HAL_UART_Receive_IT`)**으로 변경.
* **콜백 함수 활용:** `HAL_UART_RxCpltCallback` 함수를 구현하여, 메인 루프가 초음파 센서를 측정하고 있더라도 **키 입력이 들어오는 즉시(Real-time)** 하던 일을 멈추고 모터 제어 명령을 우선 수행하도록 구조 개선.
* **결과:** 센서 측정 여부와 관계없이 키보드 입력에 대해 **즉각적인 반응 속도(Zero Latency)** 확보.

| 구분 | 변경 전 (Polling) | 변경 후 (Interrupt) |
| :--- | :--- | :--- |
| **동작 방식** | "데이터 왔니?" 하고 계속 물어봄 (대기 발생) | 하던 일 하다가 "데이터 오면 알려줘" (대기 없음) |
| **CPU 점유** | 데이터 대기 중 CPU 낭비 심함 | 효율적 (이벤트 발생 시에만 처리) |
| **반응 속도** | 느림 (루프 주기에 종속됨) | **매우 빠름 (즉시 반응)** |

** 주의해야할점 **
- 인터럽트 방식은 메인루프의 할일을 새치기해서 먼저 동작하는 방식이기때문에 실제로는 인터럽트가 작동한 그만큼의 시간은 메인 루프에서 뒤로 밀리게 된다
- 다만 현재 스마트카에서는 키보드 입력시간은 약 5us정도고 초음파측정주기는 약 25ms정도이므로 25.005ms로 늘어났기때문에 실제로는 빠르게 작동된다.
- 만약 다른 예제에서 어떤 센서가 마이크로초 단위로 아주 정밀하게 작동되고있다면 그 사이에 인터럽트가 끼어들면 오차가 생길수도있으니 주의해야한다
- 
## 문제상황3
- 현재 양쪽에 IR장애물감지센서를 달았는데, 센서 자체의 감도문제인지 장애물이 나타나면 잠깐 신호가 가고 꺼지게된다
- 따라서 현재 양옆의 장애물을 측정 하지못하는 상황

** 해결 방안 **
- IR 장애물 센서의 감도를 조절
- 초음파 센서를 좌우에 단다
- 이럴경우 전방에 초음파센서 하나, 좌우에 초음파센서 두개를 달아 총 3개의 초음파센서를 사용해야할가능성
